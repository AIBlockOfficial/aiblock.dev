import ShurikenAudit from './img/d06cd07ea832dcd43423bf1b9c6b2311/shuriken-audit.png';

# Shuriken Auditing
The process of asset creation in the ZNP system works in much the same way as a coinbase transaction: users construct an asset creation transaction, spawning a value from nothing, and submit it to the [Mempool](Mempool-Node) ring for inclusion into the blockchain.

The problem with this process is that it is "free", costing neither material resource such as tokens nor computing power to perform. This, in turn, leads to potential problems for the network in general, and in particular, DDoS attacks. In order to solve this, the ZNP introduces a requirement for users hoping to create new receipt or data asset transactions.

## Auditing, a Requirement to Create New Assets

The requirement to create new assets is for the creator to audit the last *n* blocks in the blockchain for correctness, and in particular we want to audit whether a given entry in a [UNiCORN](unicorns) is actually part of the seed for that Unicorn. In this way we can check the validity of the chain as a whole and provide a way to mitigate DDoS in asset creation in a single step.

## Process Flow

As an example of the process flow, we will imagine that Alice wants to create 5 receipts. The way she does so is through the following process:

1. The [Storage](storage-node) ring sets up a presence table once per block round, which can be structured as an array or vector of boolean values.

2. For each entry in the presence table, the Storage RAFT must pick one UNiCORN seed hash and one full UNiCORN from the blockchain. Some of these entries will need to be chosen randomly from different parts of the blockchain (e.g. UNiCORN entry 1 from block 5) and the rest will need to be an entry from the same block (e.g. UNiCORN entry 3 from block 3). The former will be `false` (not present in the UNiCORN) and the latter will be `true` (is present) and for each case this boolean value will be inserted into the presence table.

3. The presence table, shared amongst the Storage RAFT, is now ready. When Alice wants to create her new receipts, she sends the creation transaction to a random Storage node and receives in return an entry in the presence table, along with the associated data required to verify whether it is present or not (this will include a difficulty for a light PoW).

4. Alice must verify whether the entry should be `true` or `false`, and then performs her PoW on this boolean value and the hash of her creation transaction. She then sends the final result back to the Storage node.

5. If Alice's verification is in agreement with the Storage nodes, a confirmation value is incremented for that presence table entry by the Storage RAFT and Alice's transaction is sent to the Mempool node.

6. If Alice's verification is **not** in agreement, the Storage node (A) will send the entry on to Bob who is also wanting to create a receipt and the disagreement will be marked in the RAFT.

7. Bob will send his verification on to the next available Storage node (B). If he is also in disagreement, the process in step 6 repeats but the difficulty that the Storage node provides increases by a factor of 10.

8. If 3 disagreements are discovered, the creation transaction for all 3 Users are immediately sent to the Mempool ring and a Storage node will manually process the entry's validity.

9. If it is found that there really is an inconsistency, some kind of halting process will need to be enacted on the Mempool ring.

## Diagram

The diagram below shows a typical shuriken audit process:

<img src={ShurikenAudit} alt="shuriken-audit" />

The table of values at the top of the diagram is the agreed upon presence table for the block round, where the number indicates index and the values "T" and "F" indicate `true` and `false` respectively. The highlighted path shows a scenario in which the Storage nodes send a User node a believed true entry, which the User then determines to actually be false.

The Storage nodes then need to repeat the process of sending on to successive User nodes until the third receipt. In this case all 3 were assessed as false, and so the fourth Storage node needs to manually perform a check on this specific entry to determine the predicate.

The faded scenarios shows cases where User nodes agree with the belief of the Storage nodes. The resulting shape of the structure is shuriken or star-like.
