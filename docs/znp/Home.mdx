# The Zenotta Network Protocol

The Zenotta Network Protocol (ZNP) is responsible for all the network-related code in the Zenotta system. It is the repo responsible for communication between nodes in the mining network, as well as integration with the blockchain data structure found in the `NAOM` repo. The following are the table of contents for further documentation below, which will fill you in on the architecture of the project as a whole:

- [Node Types](node-types)
- [Mempool Node](mempool-node)
- [Miner Node](miner-node)
- [Storage Node](storage-node)
<!-- - [The Wallet](wallet) -->
- [UNiCORNs](unicorns)
- [Transactions](transactions)
- [Block Mining Process](block-mining)
- [Dual Double Entry Transactions](dual-double-entry)
- [Shuriken Auditing](shuriken-auditing)

# Getting Started
To start, it is important to understand how the ZNP fits into the greater Zenotta system. The Zenotta system consists primarily of 3 major components:

- The Zenotta Network Protocol (ZNP)
- The Dual Double Entry (DDE) Blockchain
- The Zenotta Data Protocol (ZDP)

For now we will only consider the first two items on this list. The **ZNP** sends and receives messages that are passed between different node types, and also relays storage to the **DDE Blockchain** in order to keep a record of blockchain history.

## System Architecture
The Zenotta system architecture mirrors much of what you'll find in the Bitcoin architecture, as our blockchain is based on Proof-of-Work (PoW) consensus. Unlike traditional Bitcoin, however, our blockchain is capable of faster transaction speeds (leading to faster clearance periods) and our PoW system is light and more inclusive (but more on this later).

The other major difference between Zenotta and traditional blockchains is the introduction of the dual double entry (DDE) system. Unlike traditional blockchains, our blockchain can record both the movement of tokens *and* the movement of assets for those tokens. Thanks to our **ZDP** or Zenotta Data Protocol, those assets can be your ownable and transactable data assets.

To facilitate this, the Zenotta architecture makes use of different types of nodes in its network. You can find out more about the different node types [here](node-types).

## Code Design
We have a specific design philosophy regarding the code written at Zenotta. The ideal is to have code which will be easily reusable, but most importantly easily understandable. We treat our code like a client-server relationship, where the code is the server and you, the human user, are the client. To that end we have adopted the [Three Tier Architecture](https://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture) approach popularised by [John J. Donovan](https://en.wikipedia.org/wiki/John_J._Donovan), which in brief consists of the following:

- **Presentation Tier**: To be treated like the user interface. At this level there should be the highest abstractions for any module we write, consisting of a few easy-to-use functions that can be implemented in an API for general consumption.
***Developer Level: Beginner***

- **Logic Tier**: This is one level down from the presentation tier, where the code is more complex but is capable of more powerful functions. Logic and business operations can be found at this level, helping to facilitate the higher-level abstractions in the presentation tier. ***Developer Level: Intermediate***

- **Data Tier**: This is the lowest level of code architecture, and as such is the most complex. Functions and operations at this level will directly interact with system-level operations such as I/O and network connection handling, as well as direct interaction with the blockchain. ***Developer Level: Advanced***
